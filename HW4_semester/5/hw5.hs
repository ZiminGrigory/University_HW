--2
--Проверить, что все элементы списка удовлетворяют некоторому условию (условие передается как параметр)

import Data.List
import Control.Monad


f2 :: (Int -> Bool) -> [Int] -> Bool
f2 _ [] = False
f2 f x =  length (groupBy (\x y -> f x) x) == 1

--4
--С помощью оператора >>= опишите функцию, которая для данного числа n создает список из всех попарных произведений чисел от 1 до n. ( Т.е. что-то такое: [1*1, 1*2, 1*3, …, 1*n, 2*1, 2*2, …, n*n] - всего n*n элементов)

f4 :: Int -> [String]
f4 0 = []
f4 n = [[x , y] | x <- [1..n], y <- [1..n]] >>= \x -> map (\y -> (show(head y) ++ "*" ++ show (head $ tail y))) [x] 

f4_2 :: Int -> [Int]
f4_2 n = [[x , y] | x <- [1..n], y <- [1..n]] >>= \x -> map (product) [x] 

--3 Опишите функцию, которая для данного числа n возвращает список из всех строк длины n, состояших из чисел 1,2,3. Например, при n=2 функция должна вернуть список [[1,1], [1,2], [1,3], [2,1], [2,2], [2,3], [3,1], [3,2], [3,3],]

f3 :: Int -> [[Int]]
f3 1 = [[1], [2], [3]]
f3 n = liftM2 (++) [[1], [2], [3]] (f3 (n - 1))

--1 Реализовать функцию, которая по заданному числу n выводит все его разложения на положительные слагаемые (с точностью до порядка разложения)

f1' :: Int -> [[Int]]
f1' 0 = [[]]
f1' n = [1..n] >>= (\x -> map (x:) $ f1' (n - x) ) >>= \x -> map sort [x]  --вот только >>= nub уже не станет работать не знаю почему

f1 n = nub $ f1' n

--5 Используя монадичесие функции, опишите фунцию, которая ищет в списке первый элемент, больший своих соседей (предыдущего и следующего)

firstBig:: [Int] -> Maybe Int
firstBig [_] = Nothing
firstBig [_,_] = Nothing
firstBig (x:y:z:xs) = return xs >>= \xss -> if (x < y) && (y > z) then Just y else firstBig (y:z:xss) 

